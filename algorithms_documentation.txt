================================================================================
WATERWORKS NETWORK ANALYSIS - ALGORITHMS DOCUMENTATION
================================================================================

This document outlines the algorithms used in each section of the waterworks
network analysis project, along with the rationale for selecting each algorithm.

================================================================================
SECTION 1: GRAPH FILE PARSING
================================================================================

ALGORITHM: Sequential File Reading with State Machine Parser
- Custom parser that reads structured text files section by section
- Uses state machine approach to handle different sections ([NODES], [EDGES],
  [OFFICE], [NEW])
- Processes each line based on current section state

IMPLEMENTATION DETAILS:
- Reads header line for node/edge counts
- Switches parsing mode based on section markers
- Extracts structured data into dictionaries and lists
- Time complexity: O(n + m) where n = nodes, m = edges
- Space complexity: O(n + m)

RATIONALE:
- Simple and efficient for structured input files
- No complex algorithm needed; straightforward data extraction
- Allows flexibility in file format with section-based parsing
- Single-pass reading is optimal for sequential file access
- Easy to maintain and extend for new sections


================================================================================
SECTION 2: PIPE LENGTH CALCULATION
================================================================================

ALGORITHM: Euclidean Distance Formula
- Formula: sqrt((x2-x1)^2 + (y2-y1)^2)
- Applied to compute physical pipe lengths between connected nodes
- Updates edge data structure to include computed length

IMPLEMENTATION DETAILS:
- Iterates through all edges once
- Computes distance using node coordinates
- Stores result as 4-tuple: (u, v, weight, length)
- Time complexity: O(m) where m = number of edges
- Space complexity: O(1) per computation

RATIONALE:
- Represents real-world physical distance in 2D plane
- Accurate for planar network layouts (typical for water distribution systems)
- Simple, fast computation: O(1) per edge
- Standard geometric calculation for coordinate-based graphs
- Essential preprocessing for algorithms that need edge lengths
- Alternative (Manhattan distance) would not represent true pipe length


================================================================================
SECTION 3: NETWORK SECTORIZATION
================================================================================

ALGORITHM: Multi-Source Dijkstra's Algorithm
- Extension of single-source shortest path algorithm to multiple sources
- All pumps (sources) initialized simultaneously with distance 0
- Propagates distances from all pumps in parallel
- Uses min-heap priority queue for efficient node selection
- Includes tie-breaking mechanism (prefer lower pump ID) for balanced sectors

IMPLEMENTATION DETAILS:
- Data structure: Priority queue (binary heap via heapq)
- Queue entries: (distance, pump_id, node_id)
- Nodes assigned to nearest pump based on shortest path distance
- Undirected graph traversal
- Time complexity: O((n + m) log n) using binary heap
- Space complexity: O(n + m) for graph and auxiliary structures

RATIONALE:
- OPTIMAL for finding shortest paths from multiple sources simultaneously
- Creates balanced sectors by assigning each node to its nearest pump
- Guarantees minimum total pipeline distance within sectors
- Efficient for sparse graphs (typical in water networks where m ≈ n)
- Tie-breaking ensures deterministic, balanced sector assignment

- Better than alternatives:
  * BFS: Only works for unweighted graphs (ignores varying pipe lengths)
  * Bellman-Ford: O(nm) is slower; unnecessary since no negative weights
  * Floyd-Warshall: O(n^3) computes all-pairs, wasteful for this problem
  * Greedy geometric assignment: Would ignore network topology/connectivity
  * K-means clustering: Ignores network structure, only uses coordinates

KEY OUTPUT:
- Distance from each node to its assigned pump
- Sector label for each node (which pump it belongs to)
- List of pipes to close (edges connecting different sectors)
- Sector membership lists


================================================================================
SECTION 4: SINK NODE IDENTIFICATION
================================================================================

ALGORITHM: Linear Search for Maximum Distance
- Iterates through all nodes in each sector
- Finds node with maximum distance from pump
- Returns sink node (farthest point) per sector

IMPLEMENTATION DETAILS:
- For each sector, scan all member nodes
- Track maximum distance and corresponding node ID
- Time complexity: O(n) where n = total nodes
- Space complexity: O(k) where k = number of sectors (pumps)

RATIONALE:
- Simple, straightforward algorithm for finding maximum
- Uses distances already computed by Dijkstra in Section 3
- No complex data structures needed
- Optimal for this problem: must examine all nodes to find maximum
- Sink nodes are critical points for:
  * Water quality monitoring (oldest water)
  * Maximum flow calculations (source-to-sink paths)
  * Pressure analysis (endpoints of distribution)

NOTE ON IMPLEMENTATION EVOLUTION:
- Previous implementation included water freshness decay calculation
- Current version focuses solely on sink identification
- Removed: freshness = max(0.0, (1.0 - decay_rate) * distance)
- Simplification makes the algorithm more focused and efficient
- Water quality modeling can be added separately if needed

KEY OUTPUT:
- Dictionary mapping each pump to its sink node (farthest point)
- Used as input for maximum flow calculation in Section 5


================================================================================
SECTION 5: MAXIMUM FLOW CALCULATION
================================================================================

ALGORITHM: Ford-Fulkerson Method with Edmonds-Karp Implementation
- Uses BFS to find augmenting paths (Edmonds-Karp variant)
- Computes maximum flow from each pump to its sink node
- Implements residual graph with forward and backward edges
- Edge capacities based on pipe weights from input data

IMPLEMENTATION DETAILS:
- Capacity graph: 2D adjacency matrix
- BFS finds shortest augmenting path in residual graph
- Bottleneck capacity determined along each path
- Residual capacities updated after each augmentation
- Terminates when no augmenting path exists
- Includes reachability check before running algorithm
- Time complexity: O(nm^2) where n = nodes, m = edges
- Space complexity: O(n^2) for capacity matrix

FORD-FULKERSON ALGORITHM STEPS:
1. Initialize residual graph with original capacities
2. While augmenting path exists from source to sink:
   a. Find path using BFS
   b. Determine bottleneck (minimum capacity along path)
   c. Update residual capacities (subtract from forward, add to backward)
   d. Add bottleneck to total flow
3. Return maximum flow value

RATIONALE:
- OPTIMAL for computing maximum flow in a network
- Critical for water distribution: determines maximum water delivery capacity
- Edmonds-Karp (BFS variant) ensures polynomial time complexity
- Identifies bottleneck pipes that limit flow capacity

- Better than alternatives:
  * DFS-based Ford-Fulkerson: Can have pseudo-polynomial or infinite loops
  * Dinic's algorithm: O(n^2 m) is better asymptotically but more complex
  * Push-relabel: O(n^2 m) best case but complicated implementation
  * Capacity scaling: Adds complexity without significant benefit here

- Edmonds-Karp advantages:
  * Guaranteed O(nm^2) performance (strongly polynomial)
  * Simpler to implement than advanced flow algorithms
  * Efficient for networks of typical size (< 1000 nodes)
  * BFS finds shortest paths, often converges faster in practice
  * Well-tested, reliable, standard algorithm

KEY OUTPUT:
- Maximum flow value from each pump to its sink
- Identifies bottleneck capacity of each sector
- Critical for validating network can meet demand


================================================================================
SECTION 6: WATER QUALITY SAMPLING ROUTE
================================================================================

PROBLEM: Traveling Salesman Problem (TSP)
- Visit all nodes exactly once
- Minimize total travel distance
- Return to starting point (office)

ALGORITHMS (3-stage approach):

STAGE 1: Floyd-Warshall Algorithm (All-Pairs Shortest Paths)
- Computes shortest paths between all node pairs
- Dynamic programming approach with triple-nested loops
- Time complexity: O(n^3)
- Space complexity: O(n^2)
- Creates distance matrix for TSP solver

STAGE 2: Nearest Neighbor Heuristic (TSP Construction)
- Greedy construction: start at office, repeatedly visit nearest unvisited node
- Builds valid tour quickly
- Time complexity: O(n^2)
- Quality: typically 15-25% above optimal
- Guaranteed to produce valid tour

STAGE 3: 2-Opt Local Search (TSP Improvement)
- Local search: iteratively removes crossing edges
- Tests all possible edge swap improvements
- Continues until local optimum reached
- Time complexity: O(n^2) per iteration
- Quality: typically within 5-10% of optimal
- Significant improvement over nearest neighbor

IMPLEMENTATION DETAILS:

Floyd-Warshall:
```
for k in all nodes:
    for i in all nodes:
        for j in all nodes:
            if dist[i][k] + dist[k][j] < dist[i][j]:
                dist[i][j] = dist[i][k] + dist[k][j]
```

Nearest Neighbor:
```
current = office
while unvisited nodes exist:
    next = nearest unvisited node to current
    add next to route
    current = next
return to office
```

2-Opt:
```
repeat until no improvement:
    for each pair of edges (i,i+1) and (j,j+1):
        if swapping improves tour length:
            reverse segment between i and j
            mark as improved
```

RATIONALE:
- TSP is the CORRECT model for sampling route optimization
- Must visit all network nodes for water quality testing
- Minimize technician travel time and cost

FLOYD-WARSHALL SELECTION:
- Provides exact shortest paths between all node pairs
- Necessary because TSP route may use paths not in original graph
- One-time O(n^3) computation is acceptable for n < 100
- Alternative: Run Dijkstra n times = O(n^2 m log n) ≈ O(n^3 log n) for dense graphs
- Simpler implementation than repeated Dijkstra

NEAREST NEIGHBOR SELECTION:
- Fast, simple construction heuristic
- Always produces valid tour
- Good starting point for improvement algorithms
- Industry standard for TSP construction
- Alternative (random insertion) is more complex with similar quality

2-OPT SELECTION:
- Highly effective local search for TSP
- Significant improvement over construction heuristics
- Fast convergence for small-medium instances
- Good balance of solution quality vs. computational complexity
- Standard in routing software

WHY NOT EXACT TSP ALGORITHMS:
- Held-Karp dynamic programming: O(n^2 * 2^n) - exponential, impractical for n > 20
- Branch-and-bound: Complex implementation, overkill for small instances
- Integer programming: Requires external solvers (CPLEX, Gurobi)
- Concorde solver: External dependency, unnecessary for this size

WHY NOT OTHER METAHEURISTICS:
- Genetic algorithms: More complex, slower, similar quality
- Simulated annealing: Similar quality, more parameters, less predictable
- Ant colony optimization: Overkill for this problem size
- Lin-Kernighan: More complex than 2-opt, marginal improvement

OVERALL APPROACH JUSTIFICATION:
- Nearest Neighbor + 2-Opt is proven effective for small TSP instances
- Achieves near-optimal results (within 5-10% typically)
- Reasonable runtime: O(n^3) dominated by Floyd-Warshall
- Industry-standard approach for practical routing
- Deterministic and reproducible
- No external dependencies

KEY OUTPUT:
- Optimal or near-optimal visiting sequence
- Total route distance
- Used for planning water quality sampling campaigns


================================================================================
SECTION 7: NETWORK EXPANSION
================================================================================

ALGORITHM: Greedy Nearest Neighbor Connection with Incremental Update
- New node connects to nearest existing non-pump node
- Euclidean distance used for neighbor search
- Incremental updates to sector assignments and distances
- Local sink updates without full recomputation

IMPLEMENTATION DETAILS:
- Nearest neighbor search: O(n) per new node
- Connection strategy: minimize new pipe length
- Sector assignment: inherit from connected neighbor
- Distance update: parent_distance + connection_length
- Sink update: check if new node is farther than current sink
- Time complexity: O(kn) for k new nodes
- Space complexity: O(1) per node addition

ALGORITHM STEPS FOR EACH NEW NODE:
1. Assign new unique node ID (max existing ID + 1)
2. Search all existing nodes for nearest non-pump node
3. If no non-pump found, use nearest node of any type
4. Compute Euclidean distance to nearest node
5. Create edge: (nearest_id, new_id, weight, distance)
6. Update sector: new node inherits nearest node's sector
7. Update distance: nearest node's distance + connection distance
8. Update sink: if new node farther than current sink, replace
9. Check closed pipes: if connects different sectors, mark closed

RATIONALE:
- EFFICIENT incremental update strategy
- Avoids full re-sectorization which would be O((n+m) log n)
- Greedy nearest-neighbor connection makes practical sense:
  * Minimizes new pipe length (reduces construction cost)
  * Connects to nearby existing infrastructure
  * Reflects real-world constraints in water network expansion
  * Avoids long-distance connections

WHY NEAREST NON-PUMP NODE:
- Pumps are source nodes (should not be connection points for expansion)
- Regular nodes represent natural connection/junction points
- Maintains network topology structure
- Pump nodes already at distance 0, would create incorrect distances

INCREMENTAL UPDATE JUSTIFICATION:
- Section 7 spec allows local updates without full recomputation
- Sector inheritance is valid when adding leaf nodes
- Distance calculation is correct: d(pump→new) = d(pump→parent) + d(parent→new)
- Significant time savings: O(n) vs O((n+m) log n)
- Trade-off: speed vs. global optimality

COMPARISON TO ALTERNATIVES:
- Full re-sectorization: Correct but computationally expensive
  * Would guarantee optimal sector assignment
  * Required if adding many nodes or restructuring network
  * O((n+k+m) log(n+k)) for k new nodes

- Steiner tree connection: Optimal connection to existing network
  * NP-hard problem
  * Overkill for single-node additions
  * More relevant for multi-node expansions

- Random connection: Simple but poor quality
  * No optimization of connection distance
  * May create impractical long-distance pipes

LIMITATIONS AND ASSUMPTIONS:
- May not produce globally optimal sectorization after expansion
- Assumes new node's nearest neighbor is in the correct sector
- New nodes might theoretically be closer to a different pump
- Acceptable trade-off given efficiency requirements
- For major network changes, full re-sectorization recommended

KEY OUTPUT:
- Updated network graph with new nodes and edges
- Updated sector assignments
- Updated sink nodes (if new node becomes farthest)
- Maintains data structure consistency for dependent sections


================================================================================
COMPLEXITY SUMMARY
================================================================================

Section | Algorithm                  | Time Complexity    | Space Complexity
--------|----------------------------|-------------------|------------------
1       | File Parsing               | O(n + m)          | O(n + m)
2       | Euclidean Distance         | O(m)              | O(1)
3       | Multi-Source Dijkstra      | O((n+m) log n)    | O(n + m)
4       | Linear Maximum Search      | O(n)              | O(k)
5       | Edmonds-Karp (BFS)         | O(nm²)            | O(n²)
6       | Floyd-Warshall + TSP       | O(n³)             | O(n²)
7       | Incremental Update         | O(kn)             | O(1) per node

where: n = nodes, m = edges, k = number of pumps or new nodes

Overall program complexity: O(n³) dominated by Floyd-Warshall in Section 6
For typical sparse networks where m ≈ n, and k << n:
- Preprocessing: O(n²)
- Main analysis: O(n³)
- Per-node expansion: O(n)


================================================================================
ALGORITHM SELECTION PRINCIPLES
================================================================================

Throughout this project, algorithms were selected based on:

1. CORRECTNESS
   - Each algorithm provably solves its assigned problem
   - Well-established algorithms with known theoretical properties
   - Extensive literature and proven track record

2. EFFICIENCY
   - Polynomial time complexity for all sections
   - Appropriate for typical water network sizes (10-1000 nodes)
   - Avoided exponential-time exact algorithms where heuristics suffice
   - Balanced time complexity with solution quality

3. PRACTICAL APPLICABILITY
   - Algorithms model real-world water network constraints
   - Results are actionable for network operators
   - Inputs and outputs align with industry practices
   - Balance between optimality and computational cost

4. IMPLEMENTATION SIMPLICITY
   - Standard algorithms with clear pseudocode
   - Maintainable code without external dependencies
   - Easy to validate and debug
   - Minimal dependencies on external libraries

5. INDUSTRY STANDARDS
   - Dijkstra for shortest paths (universal standard in networks)
   - Ford-Fulkerson for max flow (network flow standard)
   - 2-opt for TSP (routing standard in logistics)
   - Proven methods used in similar real-world applications


================================================================================
ALTERNATIVE ALGORITHMS CONSIDERED AND REJECTED
================================================================================

SECTION 3 - SECTORIZATION:

Alternative: K-means Clustering
Rejected because:
- Ignores network topology, only uses geometric coordinates
- Doesn't account for connectivity constraints
- May assign nodes to unreachable pumps
- Optimal for spatial clustering, wrong for network distance

Alternative: Spectral Clustering
Rejected because:
- More complex implementation (requires eigenvalue computation)
- Similar results to Dijkstra-based approach
- Higher computational cost: O(n³) for eigendecomposition
- Less interpretable results

Alternative: Bellman-Ford Algorithm
Rejected because:
- Time complexity O(nm) is slower than Dijkstra's O((n+m) log n)
- Unnecessary since edge weights (pipe lengths) are always positive
- Only needed when negative weights are possible


SECTION 4 - SINK IDENTIFICATION:

Alternative: Maintain Max-Heap per Sector
Rejected because:
- Overkill for one-time maximum finding
- O(n log n) construction vs O(n) linear scan
- Additional space complexity O(n)
- Only beneficial for repeated queries

Alternative: Sort and Take Last Element
Rejected because:
- O(n log n) sorting vs O(n) linear scan
- Unnecessary overhead
- Less clear intent than explicit maximum search


SECTION 5 - MAXIMUM FLOW:

Alternative: Push-Relabel Algorithm
Rejected because:
- More complex implementation with height functions
- Similar worst-case complexity O(n²m)
- No practical advantage for small networks
- Harder to understand and debug

Alternative: Dinic's Algorithm
Rejected because:
- Better asymptotic complexity O(n²m) vs Edmonds-Karp O(nm²)
- More complex with blocking flows concept
- Minimal practical benefit for networks with n < 1000
- Implementation complexity not justified

Alternative: Capacity Scaling Ford-Fulkerson
Rejected because:
- Adds implementation complexity
- Requires integer capacities (may not hold with floating point)
- No significant benefit for small networks


SECTION 6 - TSP:

Alternative: Christofides Algorithm
Rejected because:
- Guarantees 3/2-approximation but more complex
- Requires perfect matching solver (Blossom algorithm)
- 2-opt often achieves similar or better results in practice
- Implementation complexity not justified for small instances

Alternative: Lin-Kernighan Heuristic
Rejected because:
- Significantly more complex than 2-opt
- Requires external libraries or complex implementation
- Marginal improvement over 2-opt for small instances
- Not worth implementation effort

Alternative: Held-Karp Dynamic Programming
Rejected because:
- Exact algorithm with O(n² × 2^n) exponential complexity
- Impractical for n > 20
- Unnecessary when heuristics achieve near-optimal solutions

Alternative: Genetic Algorithm
Rejected because:
- More complex with many parameters (population, mutation, crossover)
- Stochastic, less reproducible
- Slower convergence than local search
- Similar solution quality to 2-opt

Alternative: Simulated Annealing
Rejected because:
- Requires careful parameter tuning (temperature schedule)
- Stochastic nature reduces reproducibility
- Similar quality to 2-opt
- More complex implementation

Alternative: Multiple Fragment Heuristic
Rejected because:
- More complex than nearest neighbor
- Similar construction quality
- Less intuitive


SECTION 7 - EXPANSION:

Alternative: Full Re-sectorization with Dijkstra
Rejected because:
- Computationally expensive: O((n+k+m) log(n+k)) vs O(kn)
- Overkill for single-node additions
- Acceptable for major network restructuring
- Incremental approach sufficient for spec requirements

Alternative: Steiner Tree for Optimal Connection
Rejected because:
- NP-hard problem, exponential time
- Overkill for connecting single nodes
- Relevant for multi-node network design
- Greedy nearest neighbor is practical approximation

Alternative: Connect to Random Existing Node
Rejected because:
- No optimization objective
- May create impractically long pipes
- Ignores cost considerations
- Poor solution quality


================================================================================
CONNECTIONS BETWEEN SECTIONS
================================================================================

The algorithms in this project form a pipeline where outputs feed into
subsequent sections:

SECTION 1 → SECTION 2:
- Parsed graph structure needed for length computation
- Node coordinates and edge list are inputs to distance calculation

SECTION 2 → SECTION 3:
- Pipe lengths become edge weights for Dijkstra's algorithm
- Physical distances ensure realistic sectorization

SECTION 3 → SECTION 4:
- Distance dictionary from Dijkstra used to find maximum
- Sector groupings define scope for sink search
- Each sink is found within its sector

SECTION 4 → SECTION 5:
- Sink nodes become flow targets
- Maximum flow computed from each pump to its sink
- Validates network capacity from source to farthest point

SECTION 3 → SECTION 6:
- All node positions needed for TSP
- Office location from Section 1 is starting point
- Distances used to build all-pairs shortest path matrix

SECTION 7 → SECTIONS 3, 4, 5, 6:
- Network expansion requires updating all previous results
- Incremental updates avoid full recomputation where possible
- Section 6 (TSP) requires full recomputation with new nodes


================================================================================
PRACTICAL APPLICATIONS
================================================================================

These algorithms solve real problems in water distribution management:

SECTORIZATION (Section 3):
- Divide network into manageable zones
- Isolate contamination events
- Balance water pressure across zones
- Enable zone-based maintenance

SINK IDENTIFICATION (Section 4):
- Locate points with oldest water (quality monitoring priority)
- Identify pressure problem areas
- Plan sensor placement for monitoring systems

MAXIMUM FLOW (Section 5):
- Validate network meets demand capacity
- Identify bottleneck pipes for upgrades
- Plan for peak demand scenarios
- Ensure fire flow requirements

SAMPLING ROUTE (Section 6):
- Optimize water quality testing routes
- Minimize technician travel time and cost
- Regular compliance monitoring
- Emergency contamination surveys

NETWORK EXPANSION (Section 7):
- Plan new development connections
- Evaluate expansion scenarios
- Maintain network coherence as city grows
- Efficient "what-if" analysis


================================================================================
REFERENCES & FURTHER READING
================================================================================

FOUNDATIONAL ALGORITHMS:

1. Dijkstra's Algorithm:
   - Dijkstra, E. W. (1959). "A note on two problems in connexion with graphs"
     Numerische Mathematik, 1: 269-271

2. Ford-Fulkerson / Edmonds-Karp:
   - Ford, L. R.; Fulkerson, D. R. (1956). "Maximal flow through a network"
     Canadian Journal of Mathematics, 8: 399-404
   - Edmonds, J.; Karp, R. M. (1972). "Theoretical improvements in algorithmic
     efficiency for network flow problems"
     Journal of the ACM, 19(2): 248-264

3. Floyd-Warshall Algorithm:
   - Floyd, Robert W. (1962). "Algorithm 97: Shortest Path"
     Communications of the ACM, 5(6): 345
   - Warshall, Stephen (1962). "A theorem on Boolean matrices"
     Journal of the ACM, 9(1): 11-12

TSP HEURISTICS:

4. Nearest Neighbor and Analysis:
   - Rosenkrantz, D. J.; Stearns, R. E.; Lewis, P. M. (1977)
     "An analysis of several heuristics for the traveling salesman problem"
     SIAM Journal on Computing, 6(3): 563-581

5. 2-Opt and k-Opt Improvements:
   - Croes, G. A. (1958). "A method for solving traveling salesman problems"
     Operations Research, 6: 791-812
   - Lin, S.; Kernighan, B. W. (1973). "An Effective Heuristic Algorithm for
     the Traveling-Salesman Problem"
     Operations Research, 21(2): 498-516

WATER DISTRIBUTION NETWORKS:

6. Network Sectorization:
   - Di Nardo, A.; Di Natale, M. (2011). "A heuristic design support
     methodology based on graph theory for district metering of water
     supply networks"
     Engineering Optimization, 43(2): 193-211

7. Water Quality Modeling:
   - Rossman, L. A. (2000). "EPANET 2 Users Manual"
     U.S. Environmental Protection Agency

8. Network Design and Optimization:
   - Todini, E. (2000). "Looped water distribution networks design using a
     resilience index based heuristic approach"
     Urban Water, 2(2): 115-122
   - Walski, T. M. (1984). "Analysis of Water Distribution Systems"
     Van Nostrand Reinhold

TEXTBOOKS:

9. Algorithm Design:
   - Cormen, T. H.; Leiserson, C. E.; Rivest, R. L.; Stein, C. (2009)
     "Introduction to Algorithms" (3rd ed.)
     MIT Press

10. Network Flows:
    - Ahuja, R. K.; Magnanti, T. L.; Orlin, J. B. (1993)
      "Network Flows: Theory, Algorithms, and Applications"
      Prentice Hall


================================================================================
NOTES ON IMPLEMENTATION
================================================================================

KEY IMPLEMENTATION DECISIONS:

1. HEAPQ for Priority Queue (Section 3):
   - Python's built-in heapq provides min-heap
   - Efficient O(log n) push/pop operations
   - No external dependencies

2. Collections.deque for BFS (Section 5):
   - Efficient O(1) append and popleft
   - Better than list for queue operations
   - Standard library, no dependencies

3. 2D List for Capacity Matrix (Section 5):
   - Simple, clear implementation
   - Acceptable memory for n < 1000
   - Could use sparse matrix for larger networks

4. Dictionary for Graph Representation (Section 3):
   - Adjacency list using dict of lists
   - Memory efficient for sparse graphs
   - O(1) average case lookup

5. Floating Point for Distances/Capacities:
   - Handles real-world measurements
   - May have precision issues in flow algorithms
   - Consider decimal module for production systems


POTENTIAL IMPROVEMENTS:

1. Section 3: Priority queue with decrease-key operation
   - Fibonacci heap: O(n log n + m) vs O((n+m) log n)
   - Complex implementation, minimal practical benefit
   - Standard heapq is sufficient

2. Section 5: Sparse capacity matrix
   - Use adjacency list instead of 2D array
   - Reduces space from O(n²) to O(m)
   - Worthwhile for very large, sparse networks

3. Section 6: 3-opt or LKH for better TSP solutions
   - Marginal improvement in solution quality
   - Significant increase in complexity
   - Current 2-opt is adequate for this application

4. Section 7: Batch insertion optimization
   - Process multiple new nodes together
   - Reduce redundant computations
   - Run full Dijkstra once instead of incremental updates


================================================================================
END OF DOCUMENT
================================================================================
